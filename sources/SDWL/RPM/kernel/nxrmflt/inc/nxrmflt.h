#pragma once

#include <nudf\shared\rbtree.h>
#include <nudf\shared\keydef.h>
#include <nxlfmt.h>

//
//  Name of nxrmflt filter server ports
//

#define NXRMFLT_MSG_PORT_NAME                    L"\\nxrmfltPort9"

#ifndef NXRMFLT_FULLPATH_BUFFER_SIZE
#define NXRMFLT_FULLPATH_BUFFER_SIZE			(4*1024)
#endif

#ifndef NXRMFLT_MAX_PATH
#define NXRMFLT_MAX_PATH						(260)
#endif

#define NXRMFLT_MSG_TYPE_CHECK_RIGHTS					(0x80000001)
#define NXRMFLT_MSG_TYPE_BLOCK_NOTIFICATION				(0x80000002)
#define NXRMFLT_MSG_TYPE_FILE_ERROR_NOTIFICATION		(0x80000003)
#define NXRMFLT_MSG_TYPE_PURGE_CACHE_NOTIFICATION		(0x80000004)
#define NXRMFLT_MSG_TYPE_PROCESS_NOTIFICATION			(0x80000005)
#define NXRMFLT_MSG_TYPE_QUERY_TOKEN					(0x80000006)
#define NXRMFLT_MSG_TYPE_ACQUIRE_TOKEN					(0x80000007)
#define NXRMFLT_MSG_TYPE_ACTIVITY_LOG					(0x80000008)
#ifdef  NEXTLABS_FEATURE_SKYDRM_SANCTUARY_DIR
#define NXRMFLT_MSG_TYPE_CHECK_TRUST					(0x80000009)
#endif  // NEXTLABS_FEATURE_SKYDRM_SANCTUARY_DIR

//
//  Message timeout in 30 seconds
//
#define NXRMFLT_MSG_TIMEOUT_IN_MS				(30*1000)

#define NXRM_CEKEY_LEN							32

#define NXRM_ALGORITHM_AES256					2
		
#define NXRM_PROCESS_FLAG_HIDE_NXL_EXT				(0x0000000000000001)
#define NXRM_PROCESS_FLAG_HAS_OVERLAY_INTEGRATION	(0x0000000000000002)
#define NXRM_PROCESS_FLAG_WITH_NXL_OPENED	        (0x0000000000000004)
#define NXRM_PROCESS_FLAG_WITH_OVERLAY_OBLIGATION   (0x0000000000000008)

#pragma pack(push, 8)

typedef enum _NXRMFLT_COMMAND {

	nxrmfltInvalidCommand = 0,
	nxrmfltSaveAsForecast,
	nxrmfltGetProtectedVolumes,
	nxrmfltPolicyChanged,
	nxrmfltSessionCreated,
	nxrmfltSessionTerminated,
	nxrmfltManageSafeDir,
#ifdef  NEXTLABS_FEATURE_SKYDRM_SANCTUARY_DIR
	nxrmfltManageSanctuaryDir,
#else
	nxrmfltUnused0,
#endif  // NEXTLABS_FEATURE_SKYDRM_SANCTUARY_DIR
	nxrmfltCleanProcessCache

}NXRMFLT_COMMAND;

typedef enum _NXRMFLT_BLOCK_REASON {

	nxrmfltDeniedWritesOpen = 0x1000,
	nxrmfltDeniedSaveAsOpen,
	nxrmfltSaveAsToUnprotectedVolume

}NXRMFLT_BLOCK_REASON;


typedef enum _NXRMFLT_RPMFOLDER_OPTION {
	NXLRMFLT_RPMFOLDER_NORMAL = 1,
	NXLRMFLT_RPMFOLDER_OVERWRITE = 4,
	NXLRMFLT_RPMFOLDER_EXT = 0x10,
	NXLRMFLT_RPMFOLDER_API = 0x20
}NXRMFLT_RPMFOLDER_OPTION;

//
//  Message: Kernel -> User Message
//
typedef struct _NXRM_PURGE_CACHE_NOTIFICATION {

	WCHAR					FileName[NXRMFLT_MAX_PATH];

}NXRM_PURGE_CACHE_NOTIFICATION, *PNXRM_PURGE_CACHE_NOTIFICATION;

typedef struct _NXRM_PROCESS_NOTIFICATION {

	ULONG					SessionId;

	ULONG					ProcessId;

	ULONG					Create;			// 0 means exit; 1 means create

	ULONGLONG				Flags;			// features flag

	WCHAR					ProcessImagePath[NXRMFLT_MAX_PATH];

}NXRM_PROCESS_NOTIFICATION, *PNXRM_PROCESS_NOTIFICATION;

typedef struct _NXRM_BLOCK_NOTIFICATION {

	ULONG					ProcessId;

	ULONG					ThreadId;

	ULONG					SessionId;

	NXRMFLT_BLOCK_REASON	Reason;

	WCHAR					FileName[NXRMFLT_MAX_PATH];

} NXRM_BLOCK_NOTIFICATION, *PNXRM_BLOCK_NOTIFICATION;

typedef struct _NXRM_FILE_ERROR_NOTIFICATION {

	ULONG					SessionId;

	ULONG					Status;

	WCHAR					FileName[NXRMFLT_MAX_PATH];

} NXRM_FILE_ERROR_NOTIFICATION, *PNXRM_FILE_ERROR_NOTIFICATION;

typedef struct _NXRM_CHECK_RIGHTS_NOTIFICATION {

	ULONG						ProcessId;

	ULONG						ThreadId;

	WCHAR						FileName[NXRMFLT_FULLPATH_BUFFER_SIZE/sizeof(WCHAR)];

} NXRM_CHECK_RIGHTS_NOTIFICATION, *PNXRM_CHECK_RIGHTS_NOTIFICATION;

typedef struct _NXRM_QUERY_TOKEN_NOTIFICATION {

	ULONG						SessionId;

	ULONG						ProcessId;

	WCHAR						FileName[NXRMFLT_FULLPATH_BUFFER_SIZE / sizeof(WCHAR)];

} NXRM_QUERY_TOKEN_NOTIFICATION, *PNXRM_QUERY_TOKEN_NOTIFICATION;

typedef struct _NXRM_ACQUIRE_TOKEN_NOTIFICATION {

	ULONG						SessionId;

	CHAR						OwnerId[256];

} NXRM_ACQUIRE_TOKEN_NOTIFICATION, *PNXRM_ACQUIRE_TOKEN_NOTIFICATION;

typedef struct _NXRM_ACTIVITY_LOG_NOTIFICATION {

	ULONG						SessionId;

	ULONG						ProcessId;

	LARGE_INTEGER				Time;

	ULONG						Op;		// operation

	ULONG						Result;	// allow or deny

	WCHAR						FileName[NXRMFLT_FULLPATH_BUFFER_SIZE / sizeof(WCHAR)];

} NXRM_ACTIVITY_LOG_NOTIFICATION, *PNXRM_ACTIVITY_LOG_NOTIFICATION;

#ifdef  NEXTLABS_FEATURE_SKYDRM_SANCTUARY_DIR
typedef struct _NXRM_CHECK_TRUST_NOTIFICATION {

	ULONG						ProcessId;

} NXRM_CHECK_TRUST_NOTIFICATION, *PNXRM_CHECK_TRUST_NOTIFICATION;
#endif  // NEXTLABS_FEATURE_SKYDRM_SANCTUARY_DIR

typedef struct _NXRMFLT_NOTIFICATION
{
	ULONG									Type;

	union
	{
		NXRM_CHECK_RIGHTS_NOTIFICATION		CheckRightsMsg;

		NXRM_BLOCK_NOTIFICATION				BlockMsg;

		NXRM_FILE_ERROR_NOTIFICATION		FileErrorMsg;

		NXRM_PURGE_CACHE_NOTIFICATION		PurgeCacheMsg;

		NXRM_PROCESS_NOTIFICATION			ProcessMsg;

		NXRM_QUERY_TOKEN_NOTIFICATION		QueryTokenMsg;
		
		NXRM_ACQUIRE_TOKEN_NOTIFICATION		AcquireTokenMsg;

		NXRM_ACTIVITY_LOG_NOTIFICATION		ActivityLogMsg;

#ifdef  NEXTLABS_FEATURE_SKYDRM_SANCTUARY_DIR
		NXRM_CHECK_TRUST_NOTIFICATION		CheckTrustMsg;
#endif  // NEXTLABS_FEATURE_SKYDRM_SANCTUARY_DIR
	};

}NXRMFLT_NOTIFICATION, *PNXRMFLT_NOTIFICATION;

typedef struct _NXRMFLT_CONNECTION_CONTEXT {

	ULONG			HideNxlExtension;

	WCHAR			VirtualVolumeNTName[NXRMFLT_MAX_PATH];

}NXRMFLT_CONNECTION_CONTEXT, *PNXRMFLT_CONNECTION_CONTEXT;

//
//	Message: User -> Kernel Message
//

typedef struct _NXRMFLT_CHECK_RIGHTS_REPLY {

	ULONGLONG		RightsMask;

	ULONGLONG		CustomRights;

	ULONGLONG		EvaluationId;

}NXRMFLT_CHECK_RIGHTS_REPLY, *PNXRMFLT_CHECK_RIGHTS_REPLY;

typedef struct _NXRMFLT_QUERY_TOKEN_REPLY {

	NXL_TOKEN		Token;

	ULONGLONG		TokenTTL;	// TTL in UTC time

}NXRMFLT_QUERY_TOKEN_REPLY, *PNXRMFLT_QUERY_TOKEN_REPLY;

typedef struct _NXRMFLT_ACQUIRE_TOKEN_REPLY {

	UCHAR			Udid[16];

	ULONG			KeyFlags;

	UCHAR			PublicKey1[256];

	UCHAR			PublicKey2[256];

	NXL_TOKEN		Token;

	ULONGLONG		TokenTTL;	// TTL in UTC time

} NXRMFLT_ACQUIRE_TOKEN_REPLY, *PNXRMFLT_ACQUIRE_TOKEN_REPLY;

#ifdef  NEXTLABS_FEATURE_SKYDRM_SANCTUARY_DIR
typedef struct _NXRMFLT_CHECK_TRUST_REPLY {

	BOOLEAN			Trusted;

}NXRMFLT_CHECK_TRUST_REPLY, *PNXRMFLT_CHECK_TRUST_REPLY;
#endif  // NEXTLABS_FEATURE_SKYDRM_SANCTUARY_DIR

typedef struct _NXRMFLT_SAVEAS_FORECAST {

	ULONG						ProcessId;

	WCHAR						SaveAsFileName[NXRMFLT_MAX_PATH];

	WCHAR						SourceFileName[NXRMFLT_MAX_PATH];	// optional

}NXRMFLT_SAVEAS_FORECAST, *PNXRMFLT_SAVEAS_FORECAST;

typedef struct _NXRMFLT_SAFEDIR_INFO {

    ULONG						Cmd; // 0: delete, 1: insert, 2: remove all

    WCHAR						SafeDirPath[NXRMFLT_MAX_PATH];	// optional

}NXRMFLT_SAFEDIR_INFO, *PNXRMFLT_SAFEDIR_INFO;

#ifdef  NEXTLABS_FEATURE_SKYDRM_SANCTUARY_DIR
typedef struct _NXRMFLT_SANCTUARYDIR_INFO {

    ULONG						Cmd; // 0: delete, 1: insert, 2: remove all

    WCHAR						SanctuaryDirPath[NXRMFLT_MAX_PATH];	// optional

}NXRMFLT_SANCTUARYDIR_INFO, *PNXRMFLT_SANCTUARYDIR_INFO;
#endif  // NEXTLABS_FEATURE_SKYDRM_SANCTUARY_DIR

typedef struct _NXRMFLT_LOGON_SESSION_CREATED {

	ULONG						SessoinId;

	CHAR						Default_OwnerId[256];

}NXRMFLT_LOGON_SESSION_CREATED, *PNXRMFLT_LOGON_SESSION_CREATED;

typedef struct _NXRMFLT_LOGON_SESSION_TERMINATED {

	ULONG						SessionId;

}NXRMFLT_LOGON_SESSION_TERMINATED, *PNXRMFLT_LOGON_SESSION_TERMINATED;

typedef struct _NXRMFLT_COMMAND_MSG {

	NXRMFLT_COMMAND					Command;

	ULONG							Size;

	UCHAR							Data[1];

}NXRMFLT_COMMAND_MSG, *PNXRMFLT_COMMAND_MSG;

typedef struct _NXRMFLT_CLEAN_PROCESS_CACHE {

	ULONG						ProcessId;

}NXRMFLT_CLEAN_PROCESS_CACHE, *PNXRMFLT_CLEAN_PROCESS_CACHE;

#define NXRMFLT_SAFEDIRRELATION_SAFE_DIR							0x00000001
#define NXRMFLT_SAFEDIRRELATION_ANCESTOR_OF_SAFE_DIR				0x00000002
#define NXRMFLT_SAFEDIRRELATION_DESCENDANT_OF_SAFE_DIR				0x00000004

#ifdef  NEXTLABS_FEATURE_SKYDRM_SANCTUARY_DIR
#define NXRMFLT_SANCTUARYDIRRELATION_SANCTUARY_DIR					0x00000010
#define NXRMFLT_SANCTUARYDIRRELATION_ANCESTOR_OF_SANCTUARY_DIR		0x00000020
#define NXRMFLT_SANCTUARYDIRRELATION_DESCENDANT_OF_SANCTUARY_DIR	0x00000040
#endif  // NEXTLABS_FEATURE_SKYDRM_SANCTUARY_DIR

#pragma pack(pop)